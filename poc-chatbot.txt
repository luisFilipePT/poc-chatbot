
================================================================================
File: .gitignore
Size: 464 B
================================================================================

# Dependencies
node_modules
/.pnp
.pnp.js

# Production build files
/dist
/dist-ssr
/build

# Testing
/coverage

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
*.local

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Vite
.vite/
/.vercel


================================================================================
File: README.md
Size: 856 B
================================================================================

# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.


================================================================================
File: chatbot4.iml
Size: 296 B
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<module type="WEB_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>

================================================================================
File: eslint.config.js
Size: 844 B
================================================================================

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]


================================================================================
File: index.html
Size: 361 B
================================================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


================================================================================
File: package.json
Size: 746 B
================================================================================

{
  "name": "chatbot4",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@react-three/drei": "^10.0.8",
    "@react-three/fiber": "^9.1.2",
    "@react-three/postprocessing": "^3.0.4",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "three": "^0.176.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "vite": "^6.3.5"
  }
}


================================================================================
File: public/vite.svg
Size: 1.5 kB
================================================================================

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================================================================================
File: src/App.css
Size: 185 B
================================================================================

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body, #root {
  width: 100%;
  height: 100%;
  overflow: hidden;
}

body {
  transition: background-color 0.3s ease;
}


================================================================================
File: src/App.jsx
Size: 1.58 kB
================================================================================

import { Canvas } from '@react-three/fiber'
import { OrbitControls } from '@react-three/drei'
import { EffectComposer, Bloom } from '@react-three/postprocessing'
import Scene from './components/Scene/Scene'
import ThemeToggle from './components/ThemeToggle/ThemeToggle'
import { ThemeProvider, useTheme } from './contexts/ThemeContext'
import * as THREE from 'three'
import './App.css'

function CanvasContent() {
    const { theme } = useTheme()

    return (
        <div style={{ width: '100%', height: '100%', background: theme.background }}>
            <Canvas
                camera={{
                    position: [0, 0, 50],
                    fov: 75,
                    near: 0.1,
                    far: 1000
                }}
                gl={{
                    antialias: true,
                    alpha: true,
                    toneMapping: THREE.ACESFilmicToneMapping
                }}
                style={{ cursor: 'pointer' }}
            >
                <Scene />
                <OrbitControls enableZoom={false} enablePan={false} />
                <EffectComposer>
                    <Bloom
                        intensity={0.2}
                        luminanceThreshold={0.6}
                        luminanceSmoothing={0.9}
                        radius={0.4}
                    />
                </EffectComposer>
            </Canvas>
            <ThemeToggle />
        </div>
    )
}

function App() {
    return (
        <ThemeProvider>
            <CanvasContent />
        </ThemeProvider>
    )
}

export default App


================================================================================
File: src/assets/react.svg
Size: 4.13 kB
================================================================================

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================================================================================
File: src/components/ParticleSystem/FlockingBehavior.js
Size: 6.35 kB
================================================================================

import * as THREE from 'three'

export class FlockingBehavior {
    constructor(particleCount) {
        this.particleCount = particleCount
        this.velocities = new Float32Array(particleCount * 3)
        this.accelerations = new Float32Array(particleCount * 3)

        // Adjusted for more cohesive flocking
        this.params = {
            separationDistance: 2.0,
            alignmentDistance: 5.0,
            cohesionDistance: 5.0,
            maxSpeed: 2.0,  // Reduce from 4.0
            maxForce: 0.05,  // Reduce from 0.3
            separationWeight: 1.5,  // Reduce from 2.5
            alignmentWeight: 1.0,
            cohesionWeight: 1.0
        }

        // Initialize with more directional movement
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3
            const angle = Math.random() * Math.PI * 2
            const speed = 1.0 + Math.random() * 2.0  // Faster initial speed
            this.velocities[i3] = Math.cos(angle) * speed
            this.velocities[i3 + 1] = Math.sin(angle) * speed
            this.velocities[i3 + 2] = (Math.random() - 0.5) * 0.5
        }
    }

    update(positions, deltaTime) {
        // Reset accelerations
        this.accelerations.fill(0)

        // Calculate flocking forces for each particle
        for (let i = 0; i < this.particleCount; i++) {
            const separation = new THREE.Vector3()
            const alignment = new THREE.Vector3()
            const cohesion = new THREE.Vector3()
            let separationCount = 0
            let alignmentCount = 0
            let cohesionCount = 0

            const i3 = i * 3
            const posI = new THREE.Vector3(
                positions[i3],
                positions[i3 + 1],
                positions[i3 + 2]
            )

            // Check neighbors
            for (let j = 0; j < this.particleCount; j++) {
                if (i === j) continue

                const j3 = j * 3
                const posJ = new THREE.Vector3(
                    positions[j3],
                    positions[j3 + 1],
                    positions[j3 + 2]
                )

                const distance = posI.distanceTo(posJ)

                // Separation
                if (distance < this.params.separationDistance && distance > 0) {
                    const diff = posI.clone().sub(posJ)
                    diff.divideScalar(distance) // Weight by distance
                    separation.add(diff)
                    separationCount++
                }

                // Alignment
                if (distance < this.params.alignmentDistance) {
                    alignment.add(new THREE.Vector3(
                        this.velocities[j3],
                        this.velocities[j3 + 1],
                        this.velocities[j3 + 2]
                    ))
                    alignmentCount++
                }

                // Cohesion
                if (distance < this.params.cohesionDistance) {
                    cohesion.add(posJ)
                    cohesionCount++
                }
            }

            // Apply separation
            if (separationCount > 0) {
                separation.divideScalar(separationCount)
                separation.normalize()
                separation.multiplyScalar(this.params.maxSpeed)
                separation.sub(new THREE.Vector3(
                    this.velocities[i3],
                    this.velocities[i3 + 1],
                    this.velocities[i3 + 2]
                ))
                separation.clampLength(0, this.params.maxForce)
                separation.multiplyScalar(this.params.separationWeight)

                this.accelerations[i3] += separation.x
                this.accelerations[i3 + 1] += separation.y
                this.accelerations[i3 + 2] += separation.z
            }

            // Apply alignment
            if (alignmentCount > 0) {
                alignment.divideScalar(alignmentCount)
                alignment.normalize()
                alignment.multiplyScalar(this.params.maxSpeed)
                alignment.sub(new THREE.Vector3(
                    this.velocities[i3],
                    this.velocities[i3 + 1],
                    this.velocities[i3 + 2]
                ))
                alignment.clampLength(0, this.params.maxForce)
                alignment.multiplyScalar(this.params.alignmentWeight)

                this.accelerations[i3] += alignment.x
                this.accelerations[i3 + 1] += alignment.y
                this.accelerations[i3 + 2] += alignment.z
            }

            // Apply cohesion
            if (cohesionCount > 0) {
                cohesion.divideScalar(cohesionCount)
                cohesion.sub(posI)
                cohesion.normalize()
                cohesion.multiplyScalar(this.params.maxSpeed)
                cohesion.sub(new THREE.Vector3(
                    this.velocities[i3],
                    this.velocities[i3 + 1],
                    this.velocities[i3 + 2]
                ))
                cohesion.clampLength(0, this.params.maxForce)
                cohesion.multiplyScalar(this.params.cohesionWeight)

                this.accelerations[i3] += cohesion.x
                this.accelerations[i3 + 1] += cohesion.y
                this.accelerations[i3 + 2] += cohesion.z
            }
        }

        // Update velocities and positions
        for (let i = 0; i < this.particleCount; i++) {
            const i3 = i * 3

            // Update velocity
            this.velocities[i3] += this.accelerations[i3]
            this.velocities[i3 + 1] += this.accelerations[i3 + 1]
            this.velocities[i3 + 2] += this.accelerations[i3 + 2]

            // Limit speed
            const vel = new THREE.Vector3(
                this.velocities[i3],
                this.velocities[i3 + 1],
                this.velocities[i3 + 2]
            )
            vel.clampLength(0, this.params.maxSpeed)

            this.velocities[i3] = vel.x
            this.velocities[i3 + 1] = vel.y
            this.velocities[i3 + 2] = vel.z

            // Update position
            positions[i3] += this.velocities[i3] * deltaTime
            positions[i3 + 1] += this.velocities[i3 + 1] * deltaTime
            positions[i3 + 2] += this.velocities[i3 + 2] * deltaTime
        }
    }
}


================================================================================
File: src/components/ParticleSystem/ParticleSystem.jsx
Size: 10.66 kB
================================================================================

import {useRef, useMemo, useState, useEffect} from 'react'
import {useFrame, useThree} from '@react-three/fiber'
import * as THREE from 'three'
import {useTheme} from '../../contexts/ThemeContext'
import {FlockingBehavior} from './FlockingBehavior'
import {ShapeGeometry} from '../ShapeFormation/ShapeGeometry'
import {particleVertexShader, particleFragmentShader} from './particleShader'


function ParticleSystem({onShapeForm, targetShape}) {
    const [clickPosition, setClickPosition] = useState(null)
    const [targetSizes, setTargetSizes] = useState(null)
    const [targetPositions, setTargetPositions] = useState(null)
    const [formationStartTime, setFormationStartTime] = useState(null)
    const [particleState, setParticleState] = useState('flocking') // 'flocking', 'forming', 'formed'

    const meshRef = useRef()
    const {theme, isDark} = useTheme()
    const {viewport} = useThree()
    const particleCount = 2500
    const flocking = useRef(new FlockingBehavior(particleCount))

    // Boundary constraints
    const boundaries = {
        x: viewport.width * 0.7,  // 70% of viewport width
        y: viewport.height * 0.7, // 70% of viewport height
        z: 20
    }

    useEffect(() => {
        if (targetShape) {
            // Make it async to handle image loading
            const setupFormation = async () => {
                try {
                    const {positions: shapePositions, sizes: shapeSizes} =
                        await ShapeGeometry.generateCircularShape(
                            {x: 0, y: 0, z: 0},
                            particleCount
                        )
                    setTargetPositions(shapePositions)
                    setTargetSizes(shapeSizes)
                    setFormationStartTime(Date.now())
                    setParticleState('forming')
                    setClickPosition(targetShape.position)
                } catch (error) {
                    console.error('Failed to generate shape:', error)
                }
            }
            setupFormation()
        }
    }, [targetShape, particleCount])


    // Add this new useMemo for sizes
    const sizes = useMemo(() => {
        const s = new Float32Array(particleCount)
        for (let i = 0; i < particleCount; i++) {
            // Vary sizes for depth perception
            s[i] = 0.3 + Math.random() * 0.4
        }
        return s
    }, [particleCount])

    const filled = useMemo(() => {
        const f = new Float32Array(particleCount)
        for (let i = 0; i < particleCount; i++) {
            // 80% filled, 20% hollow
            f[i] = Math.random() < 0.8 ? 1.0 : 0.0
        }
        return f
    }, [particleCount])

    // Generate initial positions with murmuration-like distribution
    const positions = useMemo(() => {
        const pos = new Float32Array(particleCount * 3)

        // Create a diagonal flowing murmuration shape with pointed edges
        for (let i = 0; i < particleCount; i++) {
            const t = i / particleCount

            // Main diagonal flow from bottom-left to top-right
            const baseX = -20 + t * 40
            const baseY = -10 + t * 20

            // Add wave patterns for organic flow
            const wave1 = Math.sin(t * Math.PI * 3) * 4
            const wave2 = Math.cos(t * Math.PI * 5) * 2

            // Create pointed edges - narrow at ends, wide in middle
            const envelope = Math.sin(t * Math.PI) // 0 at edges, 1 at center
            const pointiness = Math.pow(envelope, 0.3) // Make the curve sharper

            // Vary the spread based on position - very narrow at tips
            const spread = pointiness * 5 + 0.2 // 0.2 to 5.2 range

            // Random offset for natural clustering
            const angle = Math.random() * Math.PI * 2
            const radius = Math.random() * spread
            const offsetX = Math.cos(angle) * radius
            const offsetY = Math.sin(angle) * radius
            const offsetZ = (Math.random() - 0.5) * 2 * pointiness

            // Apply position
            pos[i * 3] = baseX + wave1 + offsetX
            pos[i * 3 + 1] = baseY + wave2 + offsetY
            pos[i * 3 + 2] = offsetZ

            // Add very few scattered particles
            if (Math.random() < 0.02 && t > 0.1 && t < 0.9) { // 2% scattered, not at edges
                pos[i * 3] += (Math.random() - 0.5) * 5
                pos[i * 3 + 1] += (Math.random() - 0.5) * 5
            }
        }

        return pos
    }, [particleCount])


    // Particle colors for glow effect
    const colors = useMemo(() => {
        const cols = new Float32Array(particleCount * 3)
        const color = new THREE.Color(theme.particleColor)

        for (let i = 0; i < particleCount; i++) {
            // Less variation for more uniform grey
            const brightness = 0.8 + Math.random() * 0.4
            cols[i * 3] = color.r * brightness
            cols[i * 3 + 1] = color.g * brightness
            cols[i * 3 + 2] = color.b * brightness
        }
        return cols
    }, [particleCount, theme.particleColor])


    // Animation with boundary checking
    useFrame((state, delta) => {
        if (!meshRef.current) return

        const positions = meshRef.current.geometry.attributes.position.array

        if (particleState === 'flocking') {
            // Apply flocking behavior
            flocking.current.update(positions, Math.min(delta, 0.1))
        } else if ((particleState === 'forming' || particleState === 'formed') && targetPositions) {
            const elapsedTime = (Date.now() - formationStartTime) / 1000
            const time = Date.now() * 0.001

            // Continuous smooth transition that never fully completes
            const t = Math.min(elapsedTime / 5, 0.9) // Max 90%, never 100%
            const easing = t * t * (3 - 2 * t)

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3

                // Current position
                const currentX = positions[i3]
                const currentY = positions[i3 + 1]
                const currentZ = positions[i3 + 2]

                // Target position
                const targetX = targetPositions[i3]
                const targetY = targetPositions[i3 + 1]
                const targetZ = targetPositions[i3 + 2]

                // Organic movement that starts immediately
                const phase = i * 0.1
                const breathX = Math.sin(time * 0.5 + phase) * 0.5
                const breathY = Math.cos(time * 0.7 + phase * 1.3) * 0.5
                const breathZ = Math.sin(time * 0.9 + phase * 0.7) * 0.3

                // Combined target with organic offset
                const finalTargetX = targetX + breathX
                const finalTargetY = targetY + breathY
                const finalTargetZ = targetZ + breathZ

                // Smooth movement towards target + organic motion
                const moveSpeed = 0.035 * easing
                const newX = currentX + (finalTargetX - currentX) * moveSpeed
                const newY = currentY + (finalTargetY - currentY) * moveSpeed
                const newZ = currentZ + (finalTargetZ - currentZ) * moveSpeed

                // Update position
                positions[i3] = newX
                positions[i3 + 1] = newY
                positions[i3 + 2] = newZ

                // Update velocity for consistency
                flocking.current.velocities[i3] = (newX - currentX) / delta
                flocking.current.velocities[i3 + 1] = (newY - currentY) / delta
                flocking.current.velocities[i3 + 2] = (newZ - currentZ) / delta
            }

            // State transition without behavior change
            if (particleState === 'forming' && elapsedTime > 4) {
                setParticleState('formed')

                if (targetSizes) {
                    const sizeAttribute = meshRef.current.geometry.attributes.size
                    for (let i = 0; i < particleCount; i++) {
                        const currentSize = sizeAttribute.array[i]
                        const targetSize = targetSizes[i]
                        sizeAttribute.array[i] = currentSize * 0.9 + targetSize * 0.1
                    }
                    sizeAttribute.needsUpdate = true
                }

                if (onShapeForm) onShapeForm({x: 0, y: 0, z: 0})
            }
        }

        // Always apply boundary constraints
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3

            if (Math.abs(positions[i3]) > boundaries.x) {
                flocking.current.velocities[i3] *= 0.9
                flocking.current.velocities[i3] -= Math.sign(positions[i3]) * 0.1
            }
            if (Math.abs(positions[i3 + 1]) > boundaries.y) {
                flocking.current.velocities[i3 + 1] *= 0.9
                flocking.current.velocities[i3 + 1] -= Math.sign(positions[i3 + 1]) * 0.1
            }
            if (Math.abs(positions[i3 + 2]) > boundaries.z) {
                flocking.current.velocities[i3 + 2] *= 0.9
                flocking.current.velocities[i3 + 2] -= Math.sign(positions[i3 + 2]) * 0.05
            }
        }

        meshRef.current.geometry.attributes.position.needsUpdate = true
    })

    return (
        <points ref={meshRef}>
            <bufferGeometry>
                <bufferAttribute
                    attach="attributes-position"
                    count={particleCount}
                    array={positions}
                    itemSize={3}
                />
                <bufferAttribute
                    attach="attributes-color"
                    count={particleCount}
                    array={colors}
                    itemSize={3}
                />
                <bufferAttribute
                    attach="attributes-size"
                    count={particleCount}
                    array={sizes}
                    itemSize={1}
                />
                <bufferAttribute
                    attach="attributes-filled"
                    count={particleCount}
                    array={filled}
                    itemSize={1}
                />
            </bufferGeometry>
            <shaderMaterial
                vertexShader={particleVertexShader}
                fragmentShader={particleFragmentShader}
                transparent={true}
                vertexColors={true}
                blending={isDark ? THREE.AdditiveBlending : THREE.NormalBlending}  // Different blending for light mode
                depthWrite={false}
            />
        </points>
    )
}

export default ParticleSystem


================================================================================
File: src/components/ParticleSystem/particleShader.js
Size: 841 B
================================================================================

export const particleVertexShader = `
  attribute float size;
  attribute float filled;
  varying float vFilled;
  varying vec3 vColor;
  
  void main() {
    vColor = color;
    vFilled = filled;
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_PointSize = size * (300.0 / -mvPosition.z);
    gl_Position = projectionMatrix * mvPosition;
  }
`;

export const particleFragmentShader = `
  varying vec3 vColor;
  varying float vFilled;
  
  void main() {
    vec2 center = gl_PointCoord - 0.5;
    float dist = length(center);
    
    if (dist > 0.5) {
      discard;
    }
    
    if (vFilled < 0.5) {
      // Hollow circle
      if (dist < 0.4) {
        discard;
      }
      gl_FragColor = vec4(vColor, 1.0);
    } else {
      // Filled circle - full opacity
      gl_FragColor = vec4(vColor, 1.0);
    }
  }
`;




================================================================================
File: src/components/Scene/Scene.jsx
Size: 1 kB
================================================================================

import { useState } from 'react'
import ParticleSystem from '../ParticleSystem/ParticleSystem'

function Scene() {
    const [targetShape, setTargetShape] = useState(null)

    const handleClick = (event) => {
        // Set the target shape with the click position
        setTargetShape({
            position: event.point,
            timestamp: Date.now()
        })
    }

    return (
        <>
            <ambientLight intensity={0.5} />

            {/* Invisible plane for click detection */}
            <mesh
                position={[0, 0, 0]}
                onPointerDown={handleClick}
            >
                <planeGeometry args={[200, 200]} />
                <meshBasicMaterial visible={false} />
            </mesh>

            <ParticleSystem
                onShapeForm={(clickPoint) => {
                    console.log('Shape formed at:', clickPoint)
                }}
                targetShape={targetShape}
            />
        </>
    )
}

export default Scene


================================================================================
File: src/components/ShapeFormation/MeshFromImage.js
Size: 3.53 kB
================================================================================

import * as THREE from 'three'
import { MeshSurfaceSampler } from 'three/examples/jsm/math/MeshSurfaceSampler'

export class MeshFromImage {
    static async createMeshFromDensityMap(densityMapUrl, size = 20) {
        // Load the image
        const loader = new THREE.TextureLoader()
        const texture = await loader.loadAsync(densityMapUrl)
        const image = texture.image

        // Create canvas to read pixel data
        const canvas = document.createElement('canvas')
        canvas.width = image.width
        canvas.height = image.height
        const ctx = canvas.getContext('2d')
        ctx.drawImage(image, 0, 0)
        const imageData = ctx.getImageData(0, 0, image.width, image.height)

        // Create geometry from image
        const geometry = new THREE.BufferGeometry()
        const vertices = []
        const indices = []

        // Sample the image at regular intervals
        const step = 4 // Sample every 4 pixels for performance
        const threshold = 50 // Minimum brightness to create geometry

        // Create vertices based on bright pixels
        const vertexMap = new Map()
        let vertexIndex = 0

        for (let y = 0; y < image.height; y += step) {
            for (let x = 0; x < image.width; x += step) {
                const i = (y * image.width + x) * 4
                const brightness = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3

                if (brightness > threshold) {
                    const u = x / image.width
                    const v = y / image.height

                    // Convert to 3D coordinates
                    const px = (u - 0.5) * size
                    const py = (0.5 - v) * size
                    const pz = 0

                    vertices.push(px, py, pz)
                    vertexMap.set(`${x},${y}`, vertexIndex++)
                }
            }
        }

        // Create triangles between nearby bright pixels
        for (let y = 0; y < image.height - step; y += step) {
            for (let x = 0; x < image.width - step; x += step) {
                const key00 = `${x},${y}`
                const key10 = `${x + step},${y}`
                const key01 = `${x},${y + step}`
                const key11 = `${x + step},${y + step}`

                if (vertexMap.has(key00) && vertexMap.has(key10) && vertexMap.has(key01)) {
                    indices.push(
                        vertexMap.get(key00),
                        vertexMap.get(key10),
                        vertexMap.get(key01)
                    )
                }

                if (vertexMap.has(key10) && vertexMap.has(key01) && vertexMap.has(key11)) {
                    indices.push(
                        vertexMap.get(key10),
                        vertexMap.get(key11),
                        vertexMap.get(key01)
                    )
                }
            }
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))
        geometry.setIndex(indices)
        geometry.computeVertexNormals()

        return new THREE.Mesh(geometry)
    }

    static sampleMeshSurface(mesh, particleCount) {
        const sampler = new MeshSurfaceSampler(mesh).build()
        const positions = new Float32Array(particleCount * 3)
        const tempVector = new THREE.Vector3()

        for (let i = 0; i < particleCount; i++) {
            sampler.sample(tempVector)
            tempVector.toArray(positions, i * 3)
        }

        return positions
    }
}


================================================================================
File: src/components/ShapeFormation/ShapeGeometry.js
Size: 6.07 kB
================================================================================

import * as THREE from 'three'

export class ShapeGeometry {
    static imageData = null
    static imageWidth = 0
    static imageHeight = 0

    static async loadDensityMap() {
        if (this.imageData) return this.imageData

        const img = new Image()
        await new Promise((resolve, reject) => {
            img.onload = resolve
            img.onerror = reject
            img.src = '/shape-density-map.png'
        })

        const canvas = document.createElement('canvas')
        canvas.width = img.width
        canvas.height = img.height
        const ctx = canvas.getContext('2d')
        ctx.drawImage(img, 0, 0)

        this.imageData = ctx.getImageData(0, 0, img.width, img.height)
        this.imageWidth = img.width
        this.imageHeight = img.height

        return this.imageData
    }

    static async generateCircularShape(center, particleCount, radius = 20) {
        const positions = new Float32Array(particleCount * 3)
        const sizes = new Float32Array(particleCount)

        // Load image data
        const imageData = await this.loadDensityMap()
        const data = imageData.data

        // First pass: collect all bright pixels
        const brightPixels = []

        // Sample every few pixels for better performance
        const step = 2 // Sample every 2nd pixel

        for (let y = 0; y < this.imageHeight; y += step) {
            for (let x = 0; x < this.imageWidth; x += step) {
                const i = (y * this.imageWidth + x) * 4
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3

                if (brightness > 50) {
                    brightPixels.push({
                        x: x,
                        y: y,
                        brightness: brightness / 255
                    })
                }
            }
        }

        console.log(`Found ${brightPixels.length} bright pixels`)

        // Shuffle bright pixels for random distribution
        for (let i = brightPixels.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [brightPixels[i], brightPixels[j]] = [brightPixels[j], brightPixels[i]]
        }

        // Take only as many pixels as we have particles
        const selectedPixels = brightPixels.slice(0, particleCount)

        // Place particles
        for (let i = 0; i < Math.min(selectedPixels.length, particleCount); i++) {
            const pixel = selectedPixels[i]

            // Convert pixel coordinates to normalized coordinates (0-1)
            const u = pixel.x / this.imageWidth
            const v = pixel.y / this.imageHeight

            // Map to world space centered at origin
            // Increase the multiplier for larger shape
            const worldX = (u - 0.5) * radius * 3  // Increased from 2 to 3
            const worldY = (0.5 - v) * radius * 3  // Flip Y and increase scale

            // Add small random offset
            const offset = 0.1

            positions[i * 3] = worldX + (Math.random() - 0.5) * offset
            positions[i * 3 + 1] = worldY + (Math.random() - 0.5) * offset
            positions[i * 3 + 2] = (Math.random() - 0.5) * 0.5

            // Size based on brightness and distance from center
            const distFromCenter = Math.sqrt(worldX * worldX + worldY * worldY)
            const normalizedDist = distFromCenter / (radius * 1.5)

            if (normalizedDist > 0.8) {
                sizes[i] = 0.6 + pixel.brightness * 0.3
            } else if (normalizedDist > 0.5) {
                sizes[i] = 0.4 + pixel.brightness * 0.2
            } else {
                sizes[i] = 0.3 + pixel.brightness * 0.15
            }
        }

        // Fill any remaining particles (if needed)
        for (let i = selectedPixels.length; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2
            const r = Math.random() * radius * 0.5

            positions[i * 3] = Math.cos(angle) * r
            positions[i * 3 + 1] = Math.sin(angle) * r
            positions[i * 3 + 2] = 0

            sizes[i] = 0.25
        }

        return {positions, sizes}
    }

    static calculateFormationForces(
        currentPositions,
        targetPositions,
        clickPoint,
        particleCount,
        elapsedTime
    ) {
        const forces = new Float32Array(particleCount * 3)

        // For each particle, find the nearest target position
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3

            // Current particle position
            const px = currentPositions[i3]
            const py = currentPositions[i3 + 1]
            const pz = currentPositions[i3 + 2]

            // Find nearest target position
            let nearestDist = Infinity
            let nearestX = px
            let nearestY = py
            let nearestZ = pz

            // Only check nearby targets for performance
            const searchRadius = 20

            for (let j = 0; j < particleCount; j++) {
                const j3 = j * 3
                const tx = targetPositions[j3]
                const ty = targetPositions[j3 + 1]
                const tz = targetPositions[j3 + 2]

                const dx = tx - px
                const dy = ty - py
                const dz = tz - pz
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz)

                if (dist < nearestDist && dist < searchRadius) {
                    nearestDist = dist
                    nearestX = tx
                    nearestY = ty
                    nearestZ = tz
                }
            }

            // Very gentle force towards nearest target
            if (nearestDist < searchRadius && nearestDist > 0.1) {
                const strength = 0.1 * Math.min(elapsedTime / 3, 1)
                forces[i3] = (nearestX - px) / nearestDist * strength
                forces[i3 + 1] = (nearestY - py) / nearestDist * strength
                forces[i3 + 2] = (nearestZ - pz) / nearestDist * strength
            }
        }

        return forces
    }


}


================================================================================
File: src/components/ThemeToggle/ThemeToggle.css
Size: 434 B
================================================================================

.theme-toggle {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.3);
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    font-size: 24px;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 100;
}

.theme-toggle:hover {
    transform: scale(1.1);
    border-color: rgba(255, 255, 255, 0.5);
}


================================================================================
File: src/components/ThemeToggle/ThemeToggle.jsx
Size: 410 B
================================================================================

import { useTheme } from '../../contexts/ThemeContext'
import './ThemeToggle.css'

function ThemeToggle() {
    const { isDark, setIsDark } = useTheme()

    return (
        <button
            className="theme-toggle"
            onClick={() => setIsDark(!isDark)}
            aria-label="Toggle theme"
        >
            {isDark ? '☀️' : '🌙'}
        </button>
    )
}

export default ThemeToggle


================================================================================
File: src/contexts/ThemeContext.jsx
Size: 965 B
================================================================================

import { createContext, useContext, useState } from 'react'

const ThemeContext = createContext()

export const useTheme = () => useContext(ThemeContext)

export function ThemeProvider({ children }) {
    const [isDark, setIsDark] = useState(true)

    const themes = {
        dark: {
            background: '#000000',
            particleColor: '#e0e0e0',
            particleEmissive: '#ffffff',
            glowColor: '#ffffff',
            textColor: '#ffffff'
        },
        light: {
            background: '#f5f5f5',
            particleColor: '#1e40af',  // Much darker blue
            particleEmissive: '#1e3a8a',  // Even darker for contrast
            glowColor: '#1e40af',
            textColor: '#000000'
        }
    }

    const currentTheme = isDark ? themes.dark : themes.light

    return (
        <ThemeContext.Provider value={{ isDark, setIsDark, theme: currentTheme }}>
            {children}
        </ThemeContext.Provider>
    )
}


================================================================================
File: src/index.css
Size: 1.15 kB
================================================================================

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}


================================================================================
File: src/main.jsx
Size: 229 B
================================================================================

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


================================================================================
File: src/utils/ImageSampler.js
Size: 1.2 kB
================================================================================

export class ImageSampler {
    static async loadImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image()
            img.onload = () => resolve(img)
            img.onerror = reject
            img.src = url
        })
    }

    static getImageData(img) {
        const canvas = document.createElement('canvas')
        canvas.width = img.width
        canvas.height = img.height
        const ctx = canvas.getContext('2d')
        ctx.drawImage(img, 0, 0)
        return ctx.getImageData(0, 0, img.width, img.height)
    }

    static sampleDensity(imageData, x, y) {
        const px = Math.floor(x * imageData.width)
        const py = Math.floor(y * imageData.height)

        if (px < 0 || px >= imageData.width || py < 0 || py >= imageData.height) {
            return 0
        }

        const index = (py * imageData.width + px) * 4

        // Average RGB channels
        const r = imageData.data[index] / 255
        const g = imageData.data[index + 1] / 255
        const b = imageData.data[index + 2] / 255
        const avg = (r + g + b) / 3

        // Return as-is (no inversion since image is already inverted)
        return avg
    }


}


================================================================================
File: src/utils/createDensityMap.js
Size: 1.57 kB
================================================================================

export function createDensityMap() {
    const canvas = document.createElement('canvas')
    canvas.width = 512
    canvas.height = 512
    const ctx = canvas.getContext('2d')

    // Black background
    ctx.fillStyle = 'black'
    ctx.fillRect(0, 0, 512, 512)

    const centerX = 256
    const centerY = 256

    // Outer ring - white
    ctx.strokeStyle = 'white'
    ctx.lineWidth = 30
    ctx.beginPath()
    ctx.arc(centerX, centerY, 200, 0, Math.PI * 2)
    ctx.stroke()

    // Add some noise to outer ring
    for (let i = 0; i < 100; i++) {
        const angle = Math.random() * Math.PI * 2
        const r = 190 + Math.random() * 20
        const x = centerX + Math.cos(angle) * r
        const y = centerY + Math.sin(angle) * r
        ctx.fillStyle = 'white'
        ctx.beginPath()
        ctx.arc(x, y, Math.random() * 5 + 2, 0, Math.PI * 2)
        ctx.fill()
    }

    // Inner ring - gray
    ctx.strokeStyle = 'rgb(150, 150, 150)'
    ctx.lineWidth = 40
    ctx.beginPath()
    ctx.arc(centerX, centerY, 120, 0, Math.PI * 2)
    ctx.stroke()

    // Very inner ring - lighter gray
    ctx.strokeStyle = 'rgb(100, 100, 100)'
    ctx.lineWidth = 20
    ctx.beginPath()
    ctx.arc(centerX, centerY, 60, 0, Math.PI * 2)
    ctx.stroke()

    // Convert to data URL and download for reference
    const dataURL = canvas.toDataURL('image/png')

    // Optionally save it
    const link = document.createElement('a')
    link.download = 'density-map.png'
    link.href = dataURL
    // link.click() // Uncomment to auto-download

    return canvas
}


================================================================================
File: vite.config.js
Size: 161 B
================================================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

